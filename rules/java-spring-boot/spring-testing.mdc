---
description: Spring Boot testing standards for unit and integration tests with Testcontainers
globs: **/*Test.java,**/test/**/*.java
alwaysApply: true
---

# Spring Boot Testing Standards

## Context

- Apply when creating or modifying Spring Boot test classes
- For testing controllers, services, repositories, and integration scenarios
- When using Spring Boot Test framework with JUnit 5
- For both unit tests and integration tests with TestContainers
- When using jOOQ for database access and complex mocking scenarios
- Follow integration-first testing approach: comprehensive API tests, then focused unit tests
- **Note:** Some examples show Spring Boot 4-specific patterns (marked with "Spring Boot 4+"). For Spring Boot 3.5, use `PostgreSQLContainer<?>` (with generic) and `TestRestTemplate` from `org.springframework.boot.test.web.client.TestRestTemplate` without `@AutoConfigureTestRestTemplate`

## Requirements

1. **Test Strategy:** Prefer integration tests against the API first, then unit tests with mocks for specific logic testing
2. **Test Structure:** Use appropriate Spring Boot test slices (`@WebMvcTest`, `@DataJpaTest`, `@JsonTest`, etc.)
3. **Integration Tests:** Use `@SpringBootTest` with TestContainers for full integration testing
4. **Mocking:** Use `@MockBean` for Spring beans, `@Mock` for regular dependencies
5. **Test Profiles:** Use `@ActiveProfiles("test")` for test-specific configuration
6. **Database Testing:** Use TestContainers with PostgreSQL for realistic database testing
7. **Web Layer Testing:** Use MockMvc for controller testing with proper content type assertions
8. **Base Test Classes:** Use inheritance for shared test infrastructure and common setup
9. **TestContainers Configuration:** Use singleton pattern with `@ServiceConnection` for container reuse

## Examples

<example>
# Good: TestContainers Singleton Configuration (Spring Boot 4+ / Testcontainers 2.x)
# Note: For Spring Boot 3.5, use `PostgreSQLContainer<?>` (with generic type parameter)
```java
@TestConfiguration
@SuppressWarnings("resource") // Suppress false positive leak warning for singleton container
public class TestcontainersConfiguration {

    private static final Logger log = LoggerFactory.getLogger(TestcontainersConfiguration.class);
    private static final DockerImageName POSTGRES_IMAGE = DockerImageName.parse("postgres:15")
            .asCompatibleSubstituteFor("postgres");

    // Spring Boot 4+ / Testcontainers 2.x: No generic type parameter
    // Spring Boot 3.5: Use PostgreSQLContainer<?>
    private static final PostgreSQLContainer POSTGRES_CONTAINER;

    static {
        log.info("Initializing PostgreSQL Testcontainer with reuse enabled...");
        POSTGRES_CONTAINER = new PostgreSQLContainer(POSTGRES_IMAGE)
                .withDatabaseName("bookstore_test")
                .withUsername("test")
                .withPassword("test")
                .withReuse(true)
                .withStartupTimeout(Duration.ofSeconds(60))
                .withConnectTimeoutSeconds(60);

        POSTGRES_CONTAINER.start();

        // Add shutdown hook for robustness
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            if (POSTGRES_CONTAINER != null && POSTGRES_CONTAINER.isRunning()) {
                POSTGRES_CONTAINER.close();
            }
        }));
    }

    @Bean
    @ServiceConnection
    // Spring Boot 4+ / Testcontainers 2.x: No generic type parameter
    // Spring Boot 3.5: Use PostgreSQLContainer<?>
    public PostgreSQLContainer postgresContainer() {
        return POSTGRES_CONTAINER;
    }

    @DynamicPropertySource
    public static void registerDynamicProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", POSTGRES_CONTAINER::getJdbcUrl);
        registry.add("spring.datasource.username", POSTGRES_CONTAINER::getUsername);
        registry.add("spring.datasource.password", POSTGRES_CONTAINER::getPassword);
        registry.add("spring.datasource.driver-class-name", POSTGRES_CONTAINER::getDriverClassName);
    }

    // Spring Boot 4+ / Testcontainers 2.x: No generic type parameter
    // Spring Boot 3.5: Use PostgreSQLContainer<?>
    public static PostgreSQLContainer getPostgresContainer() {
        return POSTGRES_CONTAINER;
    }
}
```
</example>

<example>
# Good: Base Integration Test Class (Spring Boot 4+)
# Note: For Spring Boot 3.5, use:
#   - `@Import(TestcontainersConfiguration.class)` (without TestRestTemplateAutoConfiguration)
#   - `TestRestTemplate` from `org.springframework.boot.test.web.client.TestRestTemplate`
#   - `PostgreSQLContainer<?>` (with generic)
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestRestTemplate  // Spring Boot 4+ only
@Import({TestcontainersConfiguration.class, TestRestTemplateAutoConfiguration.class})  // Spring Boot 4+ only
@ActiveProfiles("test")
public abstract class BaseIntegrationTest {

    private static final Logger log = LoggerFactory.getLogger(BaseIntegrationTest.class);

    // Spring Boot 4+ / Testcontainers 2.x: No generic type parameter
    protected static final PostgreSQLContainer POSTGRES = TestcontainersConfiguration.getPostgresContainer();

    @LocalServerPort
    protected int port;

    @Autowired
    protected TestRestTemplate restTemplate;

    protected HttpHeaders headers;

    @BeforeEach
    void setUpBase() {
        // Verify container is running
        if (!POSTGRES.isRunning()) {
            throw new IllegalStateException("PostgreSQL container is not running!");
        }

        headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));

        log.info("PostgreSQL connection URL: {}", POSTGRES.getJdbcUrl());
    }

    protected String createBaseUrl(String path) {
        return "http://localhost:" + port + "/api/" + path;
    }
}
```
</example>

<example>
# Good: Integration Test Against API
```java
class BookControllerIntegrationTest extends BaseIntegrationTest {

    private static final Logger log = LoggerFactory.getLogger(BookControllerIntegrationTest.class);

    @Autowired
    private DSLContext dsl;

    private String booksUrl;

    @BeforeEach
    void setUp() {
        booksUrl = createBaseUrl("books");
        log.info("Using API base URL: {}", booksUrl);
    }

    @Test
    void shouldCreateBook() {
        // Given
        Book book = BookTestFixture.createTestBook("Test Book", "Test Author");
        HttpEntity<Book> request = new HttpEntity<>(book, headers);

        // When
        ResponseEntity<BookResponse> response = restTemplate.postForEntity(booksUrl, request, BookResponse.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        BookResponse created = response.getBody();
        assertThat(created).isNotNull();
        if (created != null) {
            assertThat(created.getId()).isNotNull();
            assertThat(created.getTitle()).isEqualTo(book.getTitle());
            assertThat(created.getAuthor()).isEqualTo(book.getAuthor());
        }
    }
}
```
</example>

<example>
# Good: Unit Test with jOOQ Mocking
```java
@ExtendWith(MockitoExtension.class)
class BookServiceTest {

    @Mock
    private DSLContext dsl;

    @Mock
    private RetryTemplate retryTemplate;

    @Mock
    private AuditLogger auditLogger;

    @InjectMocks
    private BookService bookService;

    @BeforeEach
    @SuppressWarnings("unchecked")
    void setUp() throws Throwable {
        when(retryTemplate.execute(any(RetryCallback.class), any(RecoveryCallback.class)))
                .thenAnswer(invocation -> {
                    RetryCallback<Object, Exception> callback = invocation.getArgument(0);
                    return callback.doWithRetry(null);
                });
    }

    @Test
    @DisplayName("findBookById should return empty Optional when book not found")
    void findBookByIdNotFound() {
        // Given
        UUID testId = UUID.randomUUID();

        @SuppressWarnings("unchecked")
        SelectWhereStep<BookRecord> selectWhereStep = mock(SelectWhereStep.class);
        @SuppressWarnings("unchecked")
        SelectConditionStep<BookRecord> selectConditionStep = mock(SelectConditionStep.class);

        when(dsl.selectFrom(BOOK)).thenReturn(selectWhereStep);
        when(selectWhereStep.where(BOOK.ID.eq(testId))).thenReturn(selectConditionStep);
        when(selectConditionStep.fetchOptional()).thenReturn(Optional.empty());

        // When
        Optional<BookResponse> result = bookService.findBookById(testId);

        // Then
        assertThat(result).isEmpty();
        verify(auditLogger, never()).logBookAccessed(any(), any(), any());
    }
}
```
</example>

<example>
# Good: MockMvc Web Layer Test
```java
@WebMvcTest(BookController.class)
@ActiveProfiles("test")
class BookControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private BookService bookService;

    @Test
    void shouldReturnBookWhenExists() throws Exception {
        // Given
        var bookId = UUID.randomUUID();
        var book = new BookResponse(bookId, "Test Book", "Test Author", "123456789");
        when(bookService.findById(bookId)).thenReturn(Optional.of(book));

        // When & Then
        mockMvc.perform(get("/api/books/{id}", bookId))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$.title").value("Test Book"));
    }
}
```
</example>

<example>
# Good: Custom JWT Security Testing
```java
@WebMvcTest(MyController.class)
@Import({MyFilter.class, MyController.class})
@ActiveProfiles("test")
class MyControllerSecurityTest {

    @Autowired
    private MockMvc mockMvc;

    @Retention(RetentionPolicy.RUNTIME)
    @WithSecurityContext(factory = WithMockJwtFactory.class)
    public @interface WithMockJwt {
        String subject() default "test-user";
    }

    static class WithMockJwtFactory implements WithSecurityContextFactory<WithMockJwt> {
        @Override
        public SecurityContext createSecurityContext(WithMockJwt annotation) {
            SecurityContext context = SecurityContextHolder.createEmptyContext();
            Map<String, Object> claims = Map.of("sub", annotation.subject());
            Jwt jwt = new Jwt("token", Instant.now(), Instant.now().plusSeconds(3600),
                             Map.of("alg", "none"), claims);
            context.setAuthentication(new JwtAuthenticationToken(jwt, Collections.emptyList()));
            return context;
        }
    }

    @Test
    @WithMockJwt(subject = "user123")
    void shouldAllowAuthenticatedAccess() throws Exception {
        mockMvc.perform(get("/test/secure"))
               .andExpect(status().isOk());
    }
}
```
</example>

## Critical Rules

- **PREFER** integration tests against the API for comprehensive coverage, then unit tests for specific logic
- **ALWAYS** use appropriate test slices (`@WebMvcTest`, `@DataJpaTest`) for focused testing
- **ALWAYS** use TestContainers for integration tests requiring databases
- **ALWAYS** use `@ActiveProfiles("test")` for test configuration
- **ALWAYS** extend base test classes for integration tests to reuse common infrastructure
- **PREFER** singleton TestContainers pattern with `@ServiceConnection` for better performance
- **USE** `@Import(TestcontainersConfiguration.class)` for consistent container setup
- **USE** `PostgreSQLContainer` (no generic type) for Testcontainers 2.x / Spring Boot 4+ compatibility. For Spring Boot 3.5, use `PostgreSQLContainer<?>` (with generic)
- **USE** `TestRestTemplate` from `org.springframework.boot.resttestclient.TestRestTemplate` with `@AutoConfigureTestRestTemplate` and `TestRestTemplateAutoConfiguration` for Spring Boot 4+ integration tests. For Spring Boot 3.5, use `TestRestTemplate` from `org.springframework.boot.test.web.client.TestRestTemplate` without auto-configuration annotations
- **MOCK** jOOQ DSL chains properly with type-safe mocking patterns
- **CREATE** custom security contexts for JWT testing when needed
- **IMPLEMENT** base test classes for shared test infrastructure
- **CONFIGURE** retry testing with proper RetryTemplate setup
- **NEVER** use `@SpringBootTest` for unit tests that can use test slices
- **ENSURE** proper MockMvc assertions include content type verification
- **VERIFY** TestContainers are running before test execution
- **USE** `@DisplayName` for descriptive test names
- **IMPLEMENT** proper cleanup in test teardown methods
